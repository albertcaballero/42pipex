
strerror

int main () {
   FILE *fp;

   fp = fopen("file.txt","r");
   if( fp == NULL ) {
      printf("Error: %s\n", strerror(errno));
   }
   
   return(0);
}
-----------------
The access() function che thus share file offset and file status flags.
Syntax:
 program, with newly initialized
       stack, heap, and (initialized and uninitialized) data segments.
----------------------------
The Fork system call is used for creating a new process in Linux, and Unix systems, which is called the child process, which runs concurrently with the process that makes the fork() call (parent process). After a new child process is created, both processes will execute the next instruction following the fork() system call.

 
 fda
 dfa
 df
 asd
 fa
 sdf
 asd
 fa
 sdf
 asd
 f
 asd
 fa
 sd
 fess uses the same pc(program counter), same CPU registers, and same open files which use in the parent process. It takes no parameters and returns an integer value.

Below are diffe
The unlink function deletes the file name filename. If this is a file’s sole name, the file itself is also deleted. (Actually, if any process has the file open when this happens, deletion is postponed until all processes have closed the file.)

The function unlink is declared in the header file unistd.h.

This function returns 0 on successful completion, and -1 on error. In addition to the usual file name errors (see File Name Errors), the following errno error conditions are defined for this function:
-------------------------
Conceptually, a pipe is a connection between two processes, such that the standard output from one process becomes the standard input of the other process. In UNIX Operating System, Pipes are useful for communication between related processes(inter-process communication).

Pipe is one-way communication only i.e we can use a pipe such that One process write to the pipe, and the other process reads from the pipe. It opens a pipe, which is an area of main memory that is treated as a “virtual file”.
The pipe can be used by the creating process, as well as all its child processes, for reading and writing. One process can write to this “virtual file” or pipe and another related process can read from it.
If a process tries to read before something is written to the pipe, the process is suspended until something is written.
The pipe system call finds the first two available positions in the process’s open file table and allocates them for the read and write ends of the pipe.
int pipe(int fds[2]);

Parameters :
fd[0] will be the fd(file descriptor) for the 
read end of pipe.
fd[1] will be the fd for the write end of pipe.
Returns : 0 on Success.
-1 on error.
Pipes behave FIFO(First in First out), Pipe behave like a queue data structure.
Size of read and write don’t have to match here. We can write 512 bytes at a time but we can read only 1 byte at a time in a pipe.
-----------------------------
A call to wait() blocks the calling process until one of its child processes exits or a signal is received. After child process terminates, parent continues its execution after wait system call instruction. 
Child process may terminate due to any of these: 

It calls exit();
It returns (an int) from main
It receives a signal (from the OS or another process) whose default action is to terminate.
If any process has more than one child processes, then after calling wait(), parent process has to be in wait state if no child terminates. 
If only one child process is terminated, then return a wait() returns process ID of the terminated child process. 
If more than one child processes are terminated than wait() reap any arbitrarily child and return a process ID of that child process. 
When wait() returns they also define exit status (which tells our, a process why terminated) via pointer, If status are not NULL.
If any process has no child process then wait() returns immediately “-1”.
------------------------------
Suspends the calling process until a child process ends or is stopped. More precisely, waitpid() suspends the calling process until the system gets status information on the child. If the system already has status information on an appropriate child when waitpid() is called, waitpid() returns immediately. waitpid() is also ended if the calling process receives a signal whose action is either to execute a signal handler or to end the process.
pid_t pid
Specifies the child processes the caller wants to wait for:
If pid is greater than 0, waitpid() waits for termination of the specific child whose process ID is equal to pid.
If pid is equal to zero, waitpid() waits for termination of any child whose process group ID is equal to that of the caller.
If pid is -1, waitpid() waits for any child process to end.
If pid is less than -1, waitpid() waits for the termination of any child whose process group ID is equal to the absolute value of pid.
int *status_ptr
Points to a location where waitpid() can store a status value. This status value is zero if the child process explicitly returns zero status. Otherwise, it is a value that can be analyzed with the status analysis macros described in “Status Analysis Macros”, below.
The status_ptr pointer may also be NULL, in which case waitpid() ignores the child's return status.

int options
Specifies additional information for waitpid(). The options value is constructed from the bitwise inclusive-OR of zero or more of the following flags defined in the sys/wait.h header file:
---------------------------
The C library function void perror(const char *str) prints a descriptive error message to stderr. First the string str is printed, followed by a colon then a space.

Declaration
Following is the declaration for perror() function.

void perror(const char *str)
Parameters
str − This is the C string containing a custom message to be printed before the error message itself.


fasdfa
same
Afs
Analysisd